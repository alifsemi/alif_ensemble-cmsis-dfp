/* Copyright (C) 2025 Alif Semiconductor - All Rights Reserved.
 * Use, distribution and modification of this code is permitted under the
 * terms stated in the Alif Semiconductor Software License Agreement
 *
 * You should have received a copy of the Alif Semiconductor Software
 * License Agreement with this file. If not, please write to:
 * contact@alifsemi.com, or visit: https://alifsemi.com/license
 *
 */

/******************************************************************************
 * @file     board_config.c
 * @author   Silesh C V
 * @email    silesh@alifsemi.com
 * @version  V1.0.1
 * @date     21-May-2025
 * @brief    Conductor tool (https://conductor.alifsemi.com/) board pin and clock configuration
 *library.
 ******************************************************************************/
#include "board_config.h"
#include "pins.h"
#include "gpios.h"
#include "gpio.h"
#include "soc.h"
#include <stdint.h>
#include <stddef.h>

#define GPIO_CTRL_DB_CKEN  (1U << 12U)
#define GPIO_CTRL_VOLT_1V8 (1U << 0U)

/**
  \fn          int32_t board_pins_config(void)
  \brief       Initialize board pins (multiplexing and config) as per information from pins.h.
  \return      0 on success, -1 on failure
*/
int32_t board_pins_config(void)
{
    size_t num_pins = sizeof(board_pinconf) / sizeof(board_pinconf[0]);

    for (size_t i = 0; i < num_pins; i++) {
        int32_t ret = pinconf_set(board_pinconf[i].port,
                                  board_pinconf[i].pin,
                                  board_pinconf[i].alternate_function,
                                  board_pinconf[i].pad_control);

        if (ret) {
            return ret;
        }
    }

#if (FLEX_IO_VOLTAGE_1V8 == 1)
    VBAT->GPIO_CTRL |= GPIO_CTRL_VOLT_1V8;
#endif

    return 0;
}

/**
  \fn          int32_t board_gpios_config(void)
  \brief       Initializes pseudo-static settings for pins configured as GPIO as per information
  from gpios.h. \return      0 on success, -1 on failure
*/
int32_t board_gpios_config(void)
{

    uint32_t instance = 0;
    size_t   i;
    size_t   num_ports = sizeof(board_gpioconf) / sizeof(board_gpioconf[0]);

    volatile GPIO_Type *regsGPIO;
    volatile GPIO_Type *regsGPIO15 = (volatile GPIO_Type *) (LPGPIO_BASE);
    volatile uint32_t  *gpio_ctrl  = (volatile uint32_t *) (&CLKCTL_PER_SLV->GPIO_CTRL[0]);

    for (i = 0; i < num_ports; i++) {
        instance = board_gpioconf[i].port_num;
        /* LPGPIO registers */
        if (instance == 15) {
            regsGPIO15->GPIO_SWPORTA_CTL   = board_gpioconf[i].hardware_mode_lptimer_on_lpgpio;
            regsGPIO15->GPIO_SWPORTA_DR    = board_gpioconf[i].initial_state_high;
            regsGPIO15->GPIO_SWPORTA_DDR   = board_gpioconf[i].direction_output;
            regsGPIO15->GPIO_DEBOUNCE      = board_gpioconf[i].debounce_enable;
            regsGPIO15->GPIO_INTTYPE_LEVEL = board_gpioconf[i].interrupt_edge;
            regsGPIO15->GPIO_INT_POLARITY  = board_gpioconf[i].interrupt_polarity_high_edge_rising;
            regsGPIO15->GPIO_INT_BOTHEDGE  = board_gpioconf[i].interrupt_both_edge;
            regsGPIO15->GPIO_INTMASK       = board_gpioconf[i].interrupt_enable;
            regsGPIO15->GPIO_INTEN         = board_gpioconf[i].interrupt_enable;
            regsGPIO15->GPIO_PORTA_EOI     = 0xFF;
        } else {
            regsGPIO                   = (GPIO_Type *) (GPIO0_BASE + (instance * GPIO_REGS_OFFSET));
            /* GPIO[instance] registers */
            regsGPIO->GPIO_SWPORTA_DR  = board_gpioconf[i].initial_state_high;
            regsGPIO->GPIO_SWPORTA_DDR = board_gpioconf[i].direction_output;
            regsGPIO->GPIO_DEBOUNCE    = board_gpioconf[i].debounce_enable;
            regsGPIO->GPIO_INTTYPE_LEVEL = board_gpioconf[i].interrupt_edge;
            regsGPIO->GPIO_INT_POLARITY  = board_gpioconf[i].interrupt_polarity_high_edge_rising;
            regsGPIO->GPIO_INT_BOTHEDGE  = board_gpioconf[i].interrupt_both_edge;
            regsGPIO->GPIO_INTMASK       = board_gpioconf[i].interrupt_enable;
            regsGPIO->GPIO_INTEN         = board_gpioconf[i].interrupt_enable;
            regsGPIO->GPIO_PORTA_EOI     = 0xFF;
            /* enable GPIO de-bounce clock if required */
            if (board_gpioconf[i].debounce_enable) {
                *(gpio_ctrl + instance) |= GPIO_CTRL_DB_CKEN;
            }
        }
    }

    return 0;
}

/**
  \fn          int32_t board_clocks_config(uint32_t clocks)
  \brief       Initialize board clocks as per information generated by the conductor tool (clocks.h)
               This call should be made after se_services_port_init().
  \return      0 on success, -1 on failure
*/
int32_t board_clocks_config(uint32_t clocks)
{
    int32_t  ret;
    uint32_t service_error_code = 0U;

    /* Enables the HFOSC clock */
    if (clocks & CLKEN_HFOSC_MASK) {
        ret = SERVICES_clocks_enable_clock(se_services_s_handle,
                                           CLKEN_HFOSC,
                                           true,
                                           &service_error_code);
        if (ret != SERVICES_REQ_SUCCESS) {
            return ret;
        }
    }

    /* Enables the 160-MHz clock */
    if (clocks & CLKEN_CLK_160M_MASK) {
        ret = SERVICES_clocks_enable_clock(se_services_s_handle,
                                           CLKEN_CLK_160M,
                                           true,
                                           &service_error_code);
        if (ret != SERVICES_REQ_SUCCESS) {
            return ret;
        }
    }

    /* Enables the 100-MHz clock */
    if (clocks & CLKEN_CLK_100M_MASK) {
        ret = SERVICES_clocks_enable_clock(se_services_s_handle,
                                           CLKEN_CLK_100M,
                                           true,
                                           &service_error_code);
        if (ret != SERVICES_REQ_SUCCESS) {
            return ret;
        }
    }

    return 0;
}
